import React, { useEffect, useRef, useState } from "react";
import { StyleSheet, Text, View } from "react-native";
import { MediaStream, RTCIceCandidate, RTCPeerConnection, RTCSessionDescription, RTCView } from "react-native-webrtc";
import { io, Socket } from "socket.io-client";
import { peerConstraints, SIGNALING_URL } from "../../web-rtc.config";

interface RtcViewerProps {
    cameraId: string;
}

export function RtcViewer({ cameraId }: RtcViewerProps) {
    const [remoteStream, setRemoteStream] = useState<MediaStream | null>(null);
    const socketRef = useRef<Socket | null>(null);
    const peerConnection = useRef<RTCPeerConnection | null>(null);

    useEffect(() => {
        if (!cameraId) return;

        socketRef.current = io(SIGNALING_URL);

        // Initialize Peer Connection (No Media Request)
        peerConnection.current = new RTCPeerConnection(peerConstraints);

        // Handle ICE Candidates generated by the Viewer
        (peerConnection as any).onicecandidate = (event: RTCPeerConnectionIceEvent) => {
            if (event.candidate && socketRef.current) {
                socketRef.current.emit("candidate", socketRef.current.id, event.candidate);
            }
        };

        // Handle Incoming Stream (Track event)
        (peerConnection as any).onaddstream = (event: { stream: MediaStream }) => {
            if (event.stream) {
                setRemoteStream(event.stream);
            }
        };

        // --- Socket Events ---

        // 1. Tell server we are a watcher for a SPECIFIC camera
        socketRef.current.emit("watcher", cameraId);

        // 2. Receive Offer from Broadcaster
        socketRef.current.on("offer", async (id: string, description: RTCSessionDescription) => {
            if (!peerConnection.current) return;

            try {
                await peerConnection.current.setRemoteDescription(description);
                const answer = await peerConnection.current.createAnswer();
                await peerConnection.current.setLocalDescription(answer);

                socketRef.current?.emit("answer", id, peerConnection.current.localDescription);
            } catch (e) {
                console.error("Error handling offer:", e);
            }
        });

        // 3. Receive ICE Candidate from Broadcaster
        socketRef.current.on("candidate", (id: string, candidate: RTCIceCandidate) => {
            peerConnection.current?.addIceCandidate(new RTCIceCandidate(candidate));
        });

        // 4. Retry if broadcaster comes online later (for THIS camera)
        socketRef.current.on("broadcaster", (onlineCameraId: string) => {
            if (onlineCameraId === cameraId) {
                socketRef.current?.emit("watcher", cameraId);
            }
        });

        return () => {
            if (peerConnection.current) peerConnection.current.close();
            socketRef.current?.disconnect();
            setRemoteStream(null);
        };
    }, [cameraId]);

    return (
        <View style={styles.container}>
            <Text style={styles.text}>Listener Mode</Text>
            {remoteStream ? (
                <RTCView streamURL={remoteStream.toURL()} style={styles.video} objectFit="cover" />
            ) : (
                <View style={styles.waiting}>
                    <Text style={styles.text}>Waiting for Broadcast...</Text>
                </View>
            )}
        </View>
    );
}

const styles = StyleSheet.create({
    container: { flex: 1, backgroundColor: "#000" },
    text: { color: "white", textAlign: "center", padding: 10 },
    video: { flex: 1 },
    waiting: { flex: 1, justifyContent: "center", alignItems: "center" },
});
